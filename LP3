# Function to find the waiting time for all processes
def findWaitingTime(processes, n, bt, wt):
    # waiting time for first process is 0
    wt[0] = 0

    # calculating waiting time for the rest of the processes
    for i in range(1, n):
        wt[i] = bt[i - 1] + wt[i - 1]

# Function to calculate turnaround time
def findTurnAroundTime(processes, n, bt, wt, tat):
    # calculating turnaround time by adding bt[i] + wt[i]
    for i in range(n):
        tat[i] = bt[i] + wt[i]

# Function to calculate average time
def findavgTime(processes, n, bt):
    wt = [0] * n
    tat = [0] * n
    total_wt = 0
    total_tat = 0

    # find waiting time of all processes
    findWaitingTime(processes, n, bt, wt)

    # find turnaround time for all processes
    findTurnAroundTime(processes, n, bt, wt, tat)

    # Display processes along with all details
    print("Processes\tBurst time\tWaiting time\tTurn around time")

    # Calculate total waiting time and total turnaround time
    for i in range(n):
        total_wt += wt[i]
        total_tat += tat[i]
        print(f"{processes[i]}\t\t{bt[i]}\t\t{wt[i]}\t\t{tat[i]}")

    print(f"\nAverage waiting time = {total_wt / n:.2f}")
    print(f"Average turn around time = {total_tat / n:.2f}")

# Driver code
if __name__ == "__main__":
    # process id's
    processes = [1, 2, 3]
    n = len(processes)

    # Burst time of all processes
    burst_time = [10, 5, 8]

    findavgTime(processes, n, burst_time)
# Function to find the waiting time for all processes (SJF Preemptive)
def findWaitingTime(processes, n, wt):
    rt = [0] * n

    # Copy the burst time into rt[]
    for i in range(n):
        rt[i] = processes[i][1]

    complete = 0
    t = 0
    minm = float('inf')
    short = 0
    check = False

    # Process until all processes get completed
    while complete != n:
        # Find process with minimum remaining time among the processes that have arrived
        minm = float('inf')
        check = False
        for j in range(n):
            if processes[j][2] <= t and rt[j] < minm and rt[j] > 0:
                minm = rt[j]
                short = j
                check = True

        if not check:
            t += 1
            continue

        # Reduce remaining time by one
        rt[short] -= 1

        # If a process gets completely executed
        if rt[short] == 0:
            complete += 1
            check = False
            fint = t + 1  # Finish time

            # Calculate waiting time
            wt[short] = fint - processes[short][1] - processes[short][2]
            if wt[short] < 0:
                wt[short] = 0

        # Increment time
        t += 1

# Function to calculate turnaround time
def findTurnAroundTime(processes, n, wt, tat):
    for i in range(n):
        tat[i] = processes[i][1] + wt[i]

# Function to calculate average waiting and turn-around times
def findavgTime(processes, n):
    wt = [0] * n
    tat = [0] * n

    findWaitingTime(processes, n, wt)
    findTurnAroundTime(processes, n, wt, tat)

    print("Processes    Burst Time    Arrival Time    Waiting Time    Turn-Around Time")
    total_wt = 0
    total_tat = 0
    for i in range(n):
        total_wt += wt[i]
        total_tat += tat[i]
        print(f"{processes[i][0]}\t\t{processes[i][1]}\t\t{processes[i][2]}\t\t{wt[i]}\t\t{tat[i]}")

    print(f"\nAverage waiting time = {total_wt / n:.2f}")
    print(f"Average turn around time = {total_tat / n:.2f}")

# Driver code
if __name__ == "__main__":
    # Process list: [Process ID, Burst Time, Arrival Time]
    proc = [[1, 6, 1], [2, 8, 1], [3, 7, 2], [4, 3, 3]]
    n = len(proc)
    findavgTime(proc, n)

# Function to find the waiting time for all processes
def findWaitingTime(processes, n, wt):
    wt[0] = 0

    # Calculating waiting time for all processes
    for i in range(1, n):
        wt[i] = processes[i - 1][1] + wt[i - 1]


# Function to calculate turnaround time
def findTurnAroundTime(processes, n, wt, tat):
    # Calculating turnaround time by adding burst time + waiting time
    for i in range(n):
        tat[i] = processes[i][1] + wt[i]


# Function to calculate average times
def findavgTime(processes, n):
    wt = [0] * n
    tat = [0] * n

    findWaitingTime(processes, n, wt)
    findTurnAroundTime(processes, n, wt, tat)

    # Display processes along with all details
    print("\nProcesses    Burst Time    Waiting Time    Turn-Around Time")
    total_wt = 0
    total_tat = 0
    for i in range(n):
        total_wt += wt[i]
        total_tat += tat[i]
        print(f" {processes[i][0]}\t\t{processes[i][1]}\t\t{wt[i]}\t\t{tat[i]}")

    print(f"\nAverage waiting time = {total_wt / n:.2f}")
    print(f"Average turn around time = {total_tat / n:.2f}")


# Function for Priority Scheduling
def priorityScheduling(proc, n):
    # Sort processes by priority (higher number = higher priority)
    proc = sorted(proc, key=lambda x: x[2], reverse=True)

    print("Order in which processes get executed:")
    for p in proc:
        print(p[0], end=" ")
    print()

    findavgTime(proc, n)


# Driver code
if __name__ == "__main__":
    # Process format: [Process ID, Burst Time, Priority]
    proc = [[1, 10, 1],
            [2, 5, 0],
            [3, 8, 1]]
    n = len(proc)
    priorityScheduling(proc, n)
# Function to find the waiting time for all processes
def findWaitingTime(processes, n, bt, wt, quantum):
    rem_bt = bt.copy()  # Remaining burst times
    t = 0  # Current time

    while True:
        done = True
        # Traverse all processes in round-robin manner
        for i in range(n):
            if rem_bt[i] > 0:
                done = False  # There is a pending process

                if rem_bt[i] > quantum:
                    t += quantum
                    rem_bt[i] -= quantum
                else:
                    t += rem_bt[i]
                    wt[i] = t - bt[i]
                    rem_bt[i] = 0
        if done:
            break

# Function to calculate turnaround time
def findTurnAroundTime(processes, n, bt, wt, tat):
    for i in range(n):
        tat[i] = bt[i] + wt[i]

# Function to calculate average waiting and turn-around times
def findavgTime(processes, n, bt, quantum):
    wt = [0] * n
    tat = [0] * n

    findWaitingTime(processes, n, bt, wt, quantum)
    findTurnAroundTime(processes, n, bt, wt, tat)

    # Display processes along with all details
    print("\nProcesses\tBurst Time\tWaiting Time\tTurn-Around Time")
    total_wt = 0
    total_tat = 0
    for i in range(n):
        total_wt += wt[i]
        total_tat += tat[i]
        print(f" {processes[i]}\t\t{bt[i]}\t\t{wt[i]}\t\t{tat[i]}")

    print(f"\nAverage waiting time = {total_wt / n:.2f}")
    print(f"Average turn around time = {total_tat / n:.2f}")

# Driver code
if __name__ == "__main__":
    # Process ids
    proc = [1, 2, 3]
    n = len(proc)

    # Burst time of all processes
    burst_time = [10, 5, 8]

    # Time quantum
    quantum = 2

    findavgTime(proc, n, burst_time, quantum)

